<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Geometric Drawing</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body { margin: 0; background: #000; }
        #svgCanvas { width: 100%; height: 65vh; border: 1px solid #fff; }
    </style>
</head>
<body>
    <svg id="svgCanvas"></svg>
    <script>
        const svg = document.getElementById('svgCanvas');
        let scale = 1;
        let translateX = 0, translateY = 0;
        let isDraggingCanvas = false;
        let startX = 0, startY = 0;
        let pinchStartDistance = 0;
        let pinchStartCenter = { x: 0, y: 0 };

        svg.setAttribute('width', window.innerWidth * 0.9);
        svg.setAttribute('height', window.innerHeight * 0.65);

        const shapeGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        shapeGroup.setAttribute('id', 'shapeGroup');
        svg.appendChild(shapeGroup);

        function drawShapes() {
            shapeGroup.innerHTML = '';
            const shape = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            shape.setAttribute('points', '100,100 200,100 200,200 100,200');
            shape.setAttribute('fill', 'none');
            shape.setAttribute('stroke', '#fff');
            shapeGroup.appendChild(shape);
            updateTransform();
        }

        function updateTransform() {
            shapeGroup.setAttribute('transform', `translate(${translateX}, ${translateY}) scale(${scale})`);
        }

        // Перемещение (работает, не трогаем)
        svg.addEventListener('mousedown', (e) => {
            if (e.button === 1) {
                isDraggingCanvas = true;
                startX = e.clientX;
                startY = e.clientY;
                e.preventDefault();
            }
        });
        svg.addEventListener('mousemove', (e) => {
            if (isDraggingCanvas) {
                translateX += e.clientX - startX;
                translateY += e.clientY - startY;
                startX = e.clientX;
                startY = e.clientY;
                updateTransform();
            }
        });
        svg.addEventListener('mouseup', () => { isDraggingCanvas = false; });

        // Зум на ПК (колёсико)
        svg.addEventListener('wheel', (e) => {
            e.preventDefault();
            const svgRect = svg.getBoundingClientRect();
            const mouseX = e.clientX - svgRect.left;
            const mouseY = e.clientY - svgRect.top;
            const oldScale = scale;

            scale *= (e.deltaY > 0 ? 0.9 : 1.1);
            if (scale < 0.0001) scale = 0.0001;

            console.log('Wheel: Before', { scale: oldScale, translateX, translateY, mouseX, mouseY });
            const scaleFactor = scale / oldScale;
            translateX += (mouseX - translateX) * (1 - scaleFactor);
            translateY += (mouseY - translateY) * (1 - scaleFactor);
            console.log('Wheel: After', { scale, translateX, translateY });

            updateTransform();
        });

        // Тачскрин
        svg.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDraggingCanvas = true;
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                pinchStartDistance = Math.hypot(touch1.clientX - touch2.clientX, touch1.clientY - touch2.clientY);
                const svgRect = svg.getBoundingClientRect();
                pinchStartCenter = {
                    x: (touch1.clientX + touch2.clientX) / 2 - svgRect.left,
                    y: (touch1.clientY + touch2.clientY) / 2 - svgRect.top
                };
                console.log('Touch start:', { pinchStartDistance, centerX: pinchStartCenter.x, centerY: pinchStartCenter.y });
            }
        });

        svg.addEventListener('touchmove', (e) => {
            if (isDraggingCanvas && e.touches.length === 1) {
                translateX += e.touches[0].clientX - startX;
                translateY += e.touches[0].clientY - startY;
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                updateTransform();
                e.preventDefault();
            } else if (e.touches.length === 2) {
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const pinchDistance = Math.hypot(touch1.clientX - touch2.clientX, touch1.clientY - touch2.clientY);
                const svgRect = svg.getBoundingClientRect();
                const centerX = (touch1.clientX + touch2.clientX) / 2 - svgRect.left;
                const centerY = (touch1.clientY + touch2.clientY) / 2 - svgRect.top;

                const oldScale = scale;
                scale *= pinchDistance / pinchStartDistance;
                if (scale < 0.0001) scale = 0.0001;

                console.log('Touch: Before', { scale: oldScale, translateX, translateY, centerX, centerY });
                const scaleFactor = scale / oldScale;
                translateX += (centerX - translateX) * (1 - scaleFactor);
                translateY += (centerY - translateY) * (1 - scaleFactor);
                pinchStartDistance = pinchDistance;
                console.log('Touch: After', { scale, translateX, translateY });

                updateTransform();
                e.preventDefault();
            }
        });

        svg.addEventListener('touchend', () => {
            isDraggingCanvas = false;
            pinchStartDistance = 0;
        });

        drawShapes();
        window.Telegram?.WebApp?.ready();
    </script>
</body>
</html>